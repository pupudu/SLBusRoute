
import java.io.File;
import java.io.FileNotFoundException;
import java.util.HashMap;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.Scanner;
import java.util.Set;
import java.util.StringTokenizer;
import java.util.TreeSet;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.swing.JComboBox;
import javax.swing.JOptionPane;
import javax.swing.UIManager;

public final class Display extends javax.swing.JFrame {

    private HashMap<String, Route> routes;
    private HashMap<String, Location> locations;
    private TreeSet<String> tree;
    private int minCount = 5;
    private int maxCount = 0;
    private Map myMap = new Map();

    public Display() {
        initComponents();
        start();
        setLocationRelativeTo(null);
        myMap.setVisible(false);
        this.setLocation(this.getX() - 100, this.getY());
        myMap.setBounds(this.getWidth() + this.getX(), this.getY(), myMap.getWidth(), this.getHeight());
        processCombo(cmbStart);
        processCombo(cmbEnd);

    }

    private void processCombo(JComboBox cmb) {
        cmb.removeAllItems();

        Set<String> keySet = locations.keySet();
        keySet.stream().sorted().forEach((loc) -> {
            cmb.addItem(loc);
        });

    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jFrame1 = new javax.swing.JFrame();
        jLabel1 = new javax.swing.JLabel();
        cmbStart = new javax.swing.JComboBox();
        cmbEnd = new javax.swing.JComboBox();
        btnSearch = new javax.swing.JButton();
        jScrollPane1 = new javax.swing.JScrollPane();
        txtDisplay = new javax.swing.JTextArea();
        btnSearchAll = new javax.swing.JButton();
        jLabel2 = new javax.swing.JLabel();
        jLabel3 = new javax.swing.JLabel();
        jLabel4 = new javax.swing.JLabel();
        chkShowMap = new javax.swing.JCheckBox();
        btnGetAllRouts = new javax.swing.JButton();
        jButton1 = new javax.swing.JButton();
        chkWarp = new javax.swing.JCheckBox();

        javax.swing.GroupLayout jFrame1Layout = new javax.swing.GroupLayout(jFrame1.getContentPane());
        jFrame1.getContentPane().setLayout(jFrame1Layout);
        jFrame1Layout.setHorizontalGroup(
            jFrame1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 400, Short.MAX_VALUE)
        );
        jFrame1Layout.setVerticalGroup(
            jFrame1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 300, Short.MAX_VALUE)
        );

        jLabel1.setText("jLabel1");

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);
        setResizable(false);

        cmbStart.setFont(new java.awt.Font("Tahoma", 0, 12)); // NOI18N
        cmbStart.setModel(new javax.swing.DefaultComboBoxModel(new String[] { "Item 1", "Item 2", "Item 3", "Item 4" }));
        cmbStart.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                cmbStartActionPerformed(evt);
            }
        });

        cmbEnd.setFont(new java.awt.Font("Tahoma", 0, 12)); // NOI18N
        cmbEnd.setModel(new javax.swing.DefaultComboBoxModel(new String[] { "Item 1", "Item 2", "Item 3", "Item 4" }));
        cmbEnd.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                cmbEndActionPerformed(evt);
            }
        });

        btnSearch.setBackground(new java.awt.Color(255, 255, 255));
        btnSearch.setText("Search Best Routes");
        btnSearch.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btnSearchActionPerformed(evt);
            }
        });

        txtDisplay.setColumns(20);
        txtDisplay.setFont(new java.awt.Font("SansSerif", 0, 14)); // NOI18N
        txtDisplay.setRows(5);
        txtDisplay.setDisabledTextColor(new java.awt.Color(255, 255, 204));
        txtDisplay.setEnabled(false);
        jScrollPane1.setViewportView(txtDisplay);

        btnSearchAll.setText("Search All Routes");
        btnSearchAll.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btnSearchAllActionPerformed(evt);
            }
        });

        jLabel2.setIcon(new javax.swing.ImageIcon(getClass().getResource("/title.png"))); // NOI18N

        jLabel3.setFont(new java.awt.Font("Trajan Pro", 0, 12)); // NOI18N
        jLabel3.setText("Start Location");

        jLabel4.setFont(new java.awt.Font("Trajan Pro", 0, 12)); // NOI18N
        jLabel4.setText("Destination");

        chkShowMap.setText("Show Colombo Map");
        chkShowMap.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                chkShowMapActionPerformed(evt);
            }
        });

        btnGetAllRouts.setText("List All Routes");
        btnGetAllRouts.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btnGetAllRoutsActionPerformed(evt);
            }
        });

        jButton1.setText("List Routes Via Start");
        jButton1.setToolTipText("List All Routes Via the Start Location");
        jButton1.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButton1ActionPerformed(evt);
            }
        });

        chkWarp.setText("Warp Text");
        chkWarp.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                chkWarpActionPerformed(evt);
            }
        });

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING, false)
                    .addComponent(jScrollPane1)
                    .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                        .addGroup(layout.createSequentialGroup()
                            .addGap(11, 11, 11)
                            .addComponent(jLabel2))
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING, false)
                            .addGroup(layout.createSequentialGroup()
                                .addComponent(chkWarp)
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                                .addComponent(chkShowMap))
                            .addGroup(layout.createSequentialGroup()
                                .addComponent(btnGetAllRouts, javax.swing.GroupLayout.PREFERRED_SIZE, 99, javax.swing.GroupLayout.PREFERRED_SIZE)
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                .addComponent(jButton1, javax.swing.GroupLayout.PREFERRED_SIZE, 177, javax.swing.GroupLayout.PREFERRED_SIZE)
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                .addComponent(btnSearch)
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                .addComponent(btnSearchAll, javax.swing.GroupLayout.PREFERRED_SIZE, 147, javax.swing.GroupLayout.PREFERRED_SIZE))
                            .addGroup(layout.createSequentialGroup()
                                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                                    .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                                        .addComponent(cmbStart, javax.swing.GroupLayout.PREFERRED_SIZE, 284, javax.swing.GroupLayout.PREFERRED_SIZE)
                                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED))
                                    .addGroup(layout.createSequentialGroup()
                                        .addComponent(jLabel3)
                                        .addGap(183, 183, 183)))
                                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                                    .addComponent(jLabel4)
                                    .addComponent(cmbEnd, javax.swing.GroupLayout.PREFERRED_SIZE, 278, javax.swing.GroupLayout.PREFERRED_SIZE))))))
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(jLabel2, javax.swing.GroupLayout.PREFERRED_SIZE, 96, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, 19, Short.MAX_VALUE)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jLabel3)
                    .addComponent(jLabel4))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(cmbStart, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(cmbEnd, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(btnSearch)
                    .addComponent(btnSearchAll)
                    .addComponent(btnGetAllRouts)
                    .addComponent(jButton1))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(chkShowMap)
                    .addComponent(chkWarp))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                .addComponent(jScrollPane1, javax.swing.GroupLayout.PREFERRED_SIZE, 243, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addContainerGap())
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

    private void btnSearchActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnSearchActionPerformed
        // TODO add your handling code here:
        if (cmbStart.getSelectedItem().toString().equals(cmbEnd.getSelectedItem().toString())) {
            JOptionPane.showMessageDialog(rootPane, "Start and End Locations are Same");
            return;
        }
        getRoutes(cmbStart.getSelectedItem().toString(), cmbEnd.getSelectedItem().toString(), false);
    }//GEN-LAST:event_btnSearchActionPerformed

    private void btnSearchAllActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnSearchAllActionPerformed
        if (cmbStart.getSelectedItem().toString().equals(cmbEnd.getSelectedItem().toString())) {
            JOptionPane.showMessageDialog(rootPane, "Start and End Locations are Same");
            return;
        }
        getRoutes(cmbStart.getSelectedItem().toString(), cmbEnd.getSelectedItem().toString(), true);
    }//GEN-LAST:event_btnSearchAllActionPerformed

    private void chkShowMapActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_chkShowMapActionPerformed
        // TODO add your handling code here:

        new Thread(new Runnable() {

            @Override
            public void run() {
                if (chkShowMap.isSelected()) {
                    myMap.setOpacity(0);
                    myMap.setVisible(true);
                    for (int i = 0; i < 100; i++) {
                        myMap.setOpacity((0.01f * i));
                        try {
                            Thread.sleep(10);
                        } catch (InterruptedException ex) {
                            Logger.getLogger(Display.class.getName()).log(Level.SEVERE, null, ex);
                        }
                    }
                } else {
                    for (int i = 99; i > 0; i--) {
                        myMap.setOpacity((0.01f * i));
                        try {
                            Thread.sleep(10);
                        } catch (InterruptedException ex) {
                            Logger.getLogger(Display.class.getName()).log(Level.SEVERE, null, ex);
                        }
                    }
                    myMap.setVisible(false);
                }
            }
        }).start();

    }//GEN-LAST:event_chkShowMapActionPerformed

    private void cmbStartActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_cmbStartActionPerformed
        // TODO add your handling code here:
        txtDisplay.setText("");
    }//GEN-LAST:event_cmbStartActionPerformed

    private void cmbEndActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_cmbEndActionPerformed
        // TODO add your handling code here:
        txtDisplay.setText("");
    }//GEN-LAST:event_cmbEndActionPerformed

    private void btnGetAllRoutsActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnGetAllRoutsActionPerformed
        // TODO add your handling code here:
        TreeSet ts = new TreeSet();
        txtDisplay.setText("");
        for (String s : routes.keySet()) {
            ts.add(s);
        }
        Iterator it = ts.iterator();
        while (it.hasNext()) {
            String key = it.next().toString();
            txtDisplay.append(key + " " + routes.get(key).toString().replaceAll("Route Out:", "").replaceAll("Route In", "").substring(0, routes.get(key).toString().length() / 2 - 9) + "\n");
        }

        //txtDisplay.setText(routes.get(cmbStart.getSelectedItem().toString()).toString());
    }//GEN-LAST:event_btnGetAllRoutsActionPerformed

    private void jButton1ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButton1ActionPerformed
        // TODO add your handling code here:
        TreeSet ts = new TreeSet();
        txtDisplay.setText("");
        for (String s : routes.keySet()) {
            ts.add(s);
        }
        Iterator it = ts.iterator();
        while (it.hasNext()) {
            String key = it.next().toString();
            String path = routes.get(key).toString().replaceAll("Route Out:", "").replaceAll("Route In", "").substring(0, routes.get(key).toString().length() / 2 - 9);
            if (path.contains(cmbStart.getSelectedItem().toString())) {
                txtDisplay.append(key + " " + path + "\n");
            }
        }
    }//GEN-LAST:event_jButton1ActionPerformed

    private void chkWarpActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_chkWarpActionPerformed
        // TODO add your handling code here:
        if (chkWarp.isSelected()) {
            txtDisplay.setLineWrap(true);
        } else {
            txtDisplay.setLineWrap(false);
        }
    }//GEN-LAST:event_chkWarpActionPerformed

    /**
     * @param args the command line arguments
     */
    public static void main(String args[]) {
        /* Set the Nimbus look and feel */
        //<editor-fold defaultstate="collapsed" desc=" Look and feel setting code (optional) ">
        /* If Nimbus (introduced in Java SE 6) is not available, stay with the default look and feel.
         * For details see http://download.oracle.com/javase/tutorial/uiswing/lookandfeel/plaf.html 
         */
        try {

            UIManager.setLookAndFeel("com.jtattoo.plaf.noire.NoireLookAndFeel");
        } catch (ClassNotFoundException ex) {
            java.util.logging.Logger.getLogger(Display.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (InstantiationException ex) {
            java.util.logging.Logger.getLogger(Display.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (IllegalAccessException ex) {
            java.util.logging.Logger.getLogger(Display.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (javax.swing.UnsupportedLookAndFeelException ex) {
            java.util.logging.Logger.getLogger(Display.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        }
        //</editor-fold>

        /* Create and display the form */
        java.awt.EventQueue.invokeLater(new Runnable() {
            public void run() {
                new Display().setVisible(true);
            }
        });
    }

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JButton btnGetAllRouts;
    private javax.swing.JButton btnSearch;
    private javax.swing.JButton btnSearchAll;
    private javax.swing.JCheckBox chkShowMap;
    private javax.swing.JCheckBox chkWarp;
    private javax.swing.JComboBox cmbEnd;
    private javax.swing.JComboBox cmbStart;
    private javax.swing.JButton jButton1;
    private javax.swing.JFrame jFrame1;
    private javax.swing.JLabel jLabel1;
    private javax.swing.JLabel jLabel2;
    private javax.swing.JLabel jLabel3;
    private javax.swing.JLabel jLabel4;
    private javax.swing.JScrollPane jScrollPane1;
    private javax.swing.JTextArea txtDisplay;
    // End of variables declaration//GEN-END:variables

    public void start() {
        routes = new HashMap<>();
        locations = new HashMap<>();
        tree = new TreeSet<>();

        loadData();
        System.out.println("++++++++++++++++++++++++");
    }

    private void getRoutes(String start, String end, boolean searchAll) {

        findRoutes(start, start, end, new LinkedList<>(), new LinkedList<>(), 3);

        txtDisplay.setText("");

        if (searchAll) {
            for (String s : tree) {
                txtDisplay.append(s + "\n");
            }
            return;
        }

        LinkedList<String> selected1 = new LinkedList();
        LinkedList<String> selected2 = new LinkedList();
        LinkedList<String> selected3 = new LinkedList();
        LinkedList<String> selected4 = new LinkedList();

        for (String s : tree) {
            int count = 0;
            StringTokenizer st = new StringTokenizer(s);
            while (st.hasMoreElements()) {
                if (st.nextToken().matches("[0-9]*")) {
                    count++;
                }
            }
            switch (count) {
                case 1:
                    selected1.add(s);
                    break;
                case 2:
                    selected2.add(s);
                    break;
                case 3:
                    selected3.add(s);
                    break;
                case 4:
                    selected4.add(s);
                    break;
                default:
                    break;
            }
            minCount = Math.min(count, minCount);
            maxCount = Math.max(count, maxCount);

            //txtDisplay.append(s+"\n");
        }
        System.out.println("Min is:" + minCount);
        switch (minCount) {
            case 0:
                txtDisplay.setText("No Root Found");
                break;
            case 1:
                txtDisplay.setText("");
                selected1.stream().forEach((sel) -> {
                    txtDisplay.append(sel + "\n");
                });
                break;
            case 2:
                txtDisplay.setText("");
                selected2.stream().forEach((sel) -> {
                    txtDisplay.append(sel + "\n");
                });
                break;
            case 3:
                txtDisplay.setText("");
                selected3.stream().forEach((sel) -> {
                    txtDisplay.append(sel + "\n");
                });
                break;
            case 4:
                txtDisplay.setText("");
                selected4.stream().forEach((sel) -> {
                    txtDisplay.append(sel + "\n");
                });
                break;
            default:
                txtDisplay.setText("Root too Long");
                break;
        }
        minCount = 5;
        tree.clear();
    }

    private void findRoutes(String start, String current, String end, LinkedList<String> tempRoutes, LinkedList<String> tempLocations, int depth) {

        if (depth > 0) {

            if (current.equals(end)) {

                String s = "";
                for (int i = 0; i < tempRoutes.size(); i++) {
                    if (i != 0) {
                        s = s + " Drop at " + tempLocations.get(i)+". ";
                    }
                    s = s + "Take " + /*tempLocations.get(i) +*/ " " + tempRoutes.get(i) + " . ";

                }

                s = s + " Get down at your destination, " + end;
                tree.add(s);

            } else {

                Location location = locations.get(current);

                for (int i = 0; i < location.getRoutes().size(); i++) {

                    Route route = location.getRoutes().get(i);
                    if (route.routeInContainsLocation(locations.get(end))) {

                        boolean isValid = true;

                        if (tempRoutes.contains(route.getRouteNumber()) || tempLocations.contains(location.getName())) {
                            isValid = false;
                        }

                        if (isValid) {
                            LinkedList<String> routesClone = new LinkedList<>();
                            routesClone.addAll(tempRoutes);

                            routesClone.add(route.getRouteNumber());

                            LinkedList<String> locationsClone = new LinkedList<>();
                            locationsClone.addAll(tempLocations);

                            locationsClone.add(location.getName());
                            findRoutes(start, end, end, routesClone, locationsClone, depth);

                        }
                    } else {

                        if (!tempRoutes.contains(route.getRouteNumber()) && !tempLocations.contains(location.getName())) {

                            LinkedList<String> routesClone = new LinkedList<>();
                            routesClone.addAll(tempRoutes);

                            routesClone.add(route.getRouteNumber());

                            LinkedList<String> locationsClone = new LinkedList<>();
                            locationsClone.addAll(tempLocations);

                            locationsClone.add(location.getName());

                            boolean isValid = true;

                            for (String previous : tempLocations) {
                                for (Route r : locations.get(previous).getRoutes()) {
                                    if (r.routeInContainsLocation(location) && !locations.get(previous).getName().equals(start)) {
                                        isValid = false;
                                    }
                                    if (r.routeOutContainsLocation(location) && !locations.get(previous).getName().equals(start)) {
                                        isValid = false;
                                    }
                                }
                                if (previous.equals(location.getName())) {
                                    isValid = false;
                                }
                            }

                            if (isValid) {

                                for (Location loc : route.getRouteIn()) {
                                    findRoutes(start, loc.getName(), end, routesClone, locationsClone, depth - 1);
                                }

                                for (Location loc : route.getRouteOut()) {
                                    findRoutes(start, loc.getName(), end, routesClone, locationsClone, depth - 1);
                                }
                            }
                        }
                    }
                }
            }
        }
    }

    private void loadData() {

        try {
            Scanner scanner = new Scanner(new File("Data.dat"));

            String line;
            String[] temp;
            Route route;

            while (scanner.hasNextLine()) {

                line = scanner.nextLine();
                temp = line.split("[|]");
                route = new Route(temp[0]);

                route = processInput(temp[1], route);
                route = processInput(temp[2], route);
                routes.put(temp[0], route);
            }
            scanner.close();
        } catch (FileNotFoundException e) {
            System.out.println("Error Occurred: " + e);
        }
    }

    private Route processInput(String temp, Route route) {
        Location location;
        String[] tempLocations = temp.split(",");

        for (String s : tempLocations) {
            if (!locations.containsKey(s)) {
                location = new Location(s);
                route.addLocationToRouteIn(location);
                locations.put(s, location);
            } else {
                route.addLocationToRouteIn(locations.get(s));
            }
        }
        return route;
    }
}
